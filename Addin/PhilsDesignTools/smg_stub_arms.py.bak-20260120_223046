import adsk.core, adsk.fusion, traceback, os
import smg_context as ctx
import smg_logger as logger


CMD_ID = "PhilsDesignTools_StubArms"
CMD_NAME = "Stub Arms To Wall"
CMD_TOOLTIP = "Create stub arm sketch lines from RHS columns to the wall."
RESOURCE_FOLDER = os.path.join(os.path.dirname(__file__), "resources", CMD_ID)

TOL = 1e-6
ANGLE_TOL = 1e-3
DEBUG_STUB_ARMS = True


class StubArmsExecuteHandler(adsk.core.CommandEventHandler):
    def notify(self, args):
        try:
            _execute(args)
        except:
            logger.log("Stub Arms command failed:\n" + traceback.format_exc())
            ctx.ui().messageBox("Stub Arms command failed:\n" + traceback.format_exc())


class StubArmsCreatedHandler(adsk.core.CommandCreatedEventHandler):
    def notify(self, args):
        try:
            design = adsk.fusion.Design.cast(ctx.app().activeProduct)
            if not design:
                ctx.ui().messageBox("No active design.")
                return
            um = design.unitsManager
            length_units = um.defaultLengthUnits or "mm"

            cmd = args.command
            cmd.isRepeatable = True
            inputs = cmd.commandInputs

            if inputs.itemById("stub_cols"):
                return

            sel_cols = inputs.addSelectionInput(
                "stub_cols",
                "RHS/SHS columns",
                "Select RHS/SHS column bodies or occurrences"
            )
            sel_cols.addSelectionFilter("Bodies")
            sel_cols.addSelectionFilter("Occurrences")
            sel_cols.setSelectionLimits(1, 0)

            sel_wall = inputs.addSelectionInput(
                "stub_wall",
                "Wall faces",
                "Select wall faces or surface bodies"
            )
            sel_wall.addSelectionFilter("Faces")
            sel_wall.addSelectionFilter("Bodies")
            sel_wall.setSelectionLimits(1, 0)

            inputs.addIntegerSpinnerCommandInput(
                "stub_points",
                "Connection points",
                2,
                20,
                1,
                6
            )

            def v(mm):
                return adsk.core.ValueInput.createByString(f"{mm} mm")

            inputs.addValueInput("stub_bottom", "Bottom offset", length_units, v(500.0))
            inputs.addValueInput("stub_top", "Top offset", length_units, v(150.0))
            inputs.addValueInput("stub_inboard", "Inboard offset", length_units, v(25.0))

            on_exec = StubArmsExecuteHandler()
            cmd.execute.add(on_exec)
            ctx.add_handler(on_exec)
        except:
            logger.log("Stub Arms CommandCreated failed:\n" + traceback.format_exc())
            ctx.ui().messageBox("Stub Arms CommandCreated failed:\n" + traceback.format_exc())


def _dbg(message):
    if DEBUG_STUB_ARMS:
        logger.log(f"{CMD_NAME} DEBUG: {message}")


def _normalise(v):
    out = adsk.core.Vector3D.create(v.x, v.y, v.z)
    if out.length > TOL:
        out.normalize()
    return out


def _canon_dir(v):
    v2 = _normalise(v)
    if v2.x < 0 or (abs(v2.x) < TOL and v2.y < 0) or \
       (abs(v2.x) < TOL and abs(v2.y) < TOL and v2.z < 0):
        v2.scaleBy(-1)
    return v2


def _get_body_center(body):
    try:
        props = body.physicalProperties
        if props:
            com = props.centerOfMass
            if com:
                return com
    except:
        pass

    bb = body.boundingBox
    mp = bb.minPoint
    xp = bb.maxPoint
    return adsk.core.Point3D.create(
        (mp.x + xp.x) * 0.5,
        (mp.y + xp.y) * 0.5,
        (mp.z + xp.z) * 0.5,
    )


def _get_body_axis(body):
    clusters = []
    for e in body.edges:
        line = adsk.core.Line3D.cast(e.geometry)
        if not line:
            continue
        sp = line.startPoint
        ep = line.endPoint
        vec = adsk.core.Vector3D.create(
            ep.x - sp.x,
            ep.y - sp.y,
            ep.z - sp.z,
        )
        length = vec.length
        if length < TOL:
            continue
        d = _canon_dir(vec)

        placed = False
        for c in clusters:
            if c["dir"].crossProduct(d).length < ANGLE_TOL:
                c["tot"] += length
                placed = True
                break
        if not placed:
            clusters.append({"dir": d, "tot": length})

    if not clusters:
        return None

    clusters.sort(key=lambda c: c["tot"], reverse=True)
    return clusters[0]["dir"]


def _axis_endpoints(body, axis):
    center = _get_body_center(body)
    if not center or not axis:
        return None, None, None, None

    min_t = None
    max_t = None
    for v in body.vertices:
        p = v.geometry
        diff = adsk.core.Vector3D.create(
            p.x - center.x,
            p.y - center.y,
            p.z - center.z,
        )
        t = diff.dotProduct(axis)
        if min_t is None:
            min_t = max_t = t
        else:
            min_t = min(min_t, t)
            max_t = max(max_t, t)

    if min_t is None or abs(max_t - min_t) < TOL:
        return None, None, None, None

    bottom = adsk.core.Point3D.create(
        center.x + axis.x * min_t,
        center.y + axis.y * min_t,
        center.z + axis.z * min_t,
    )
    top = adsk.core.Point3D.create(
        center.x + axis.x * max_t,
        center.y + axis.y * max_t,
        center.z + axis.z * max_t,
    )

    axis_vec = adsk.core.Vector3D.create(
        top.x - bottom.x,
        top.y - bottom.y,
        top.z - bottom.z,
    )
    if axis_vec.length < TOL:
        return None, None, None, None
    axis_vec.normalize()
    length = bottom.distanceTo(top)
    return axis_vec, bottom, top, length


def _name_matches_rhs_shs(name):
    if not name:
        return False
    upper = name.strip().upper()
    return upper.startswith("RHS") or upper.startswith("SHS")


def _looks_like_rhs_shs(body, axis_dir):
    if not body or not axis_dir:
        return False
    side_faces = []
    for face in body.faces:
        plane = adsk.core.Plane.cast(face.geometry)
        if not plane:
            continue
        n = plane.normal
        if not n or n.length < TOL:
            continue
        n_vec = adsk.core.Vector3D.create(n.x, n.y, n.z)
        n_vec.normalize()
        if abs(n_vec.dotProduct(axis_dir)) > 0.2:
            continue
        side_faces.append(n_vec)

    if len(side_faces) < 4:
        return False

    clusters = []
    for n_vec in side_faces:
        d = _canon_dir(n_vec)
        placed = False
        for c in clusters:
            if c["dir"].crossProduct(d).length < ANGLE_TOL:
                c["count"] += 1
                placed = True
                break
        if not placed:
            clusters.append({"dir": d, "count": 1})

    return len(clusters) >= 2


def _offset_point(p, d, dist):
    return adsk.core.Point3D.create(
        p.x + d.x * dist,
        p.y + d.y * dist,
        p.z + d.z * dist,
    )


def _get_face_plane(face):
    if not face:
        return None
    try:
        res = face.evaluator.getPlane()
        if isinstance(res, tuple):
            if res[0]:
                return res[1]
        elif res:
            return res
    except:
        pass
    return adsk.core.Plane.cast(face.geometry)


def _line_plane_intersection(origin, direction, plane):
    if not plane or direction.length < TOL:
        return None
    n = plane.normal
    if not n or n.length < TOL:
        return None
    denom = n.dotProduct(direction)
    if abs(denom) < TOL:
        return None
    v = adsk.core.Vector3D.create(
        plane.origin.x - origin.x,
        plane.origin.y - origin.y,
        plane.origin.z - origin.z,
    )
    t = n.dotProduct(v) / denom
    return adsk.core.Point3D.create(
        origin.x + direction.x * t,
        origin.y + direction.y * t,
        origin.z + direction.z * t,
    )


def _is_point_on_face(face, point):
    if not face or not point:
        return False
    try:
        if hasattr(face, "isPointOnFace"):
            res = face.isPointOnFace(point)
            if isinstance(res, tuple):
                return bool(res[0])
            return bool(res)
    except:
        pass
    try:
        ev = face.evaluator
        if hasattr(ev, "isPointOnFace"):
            res = ev.isPointOnFace(point)
            if isinstance(res, tuple):
                return bool(res[0])
            return bool(res)
    except:
        pass
    try:
        if hasattr(face.evaluator, "getClosestPointTo"):
            res = face.evaluator.getClosestPointTo(point)
        else:
            res = face.evaluator.getClosestPoint(point)
    except:
        return False
    if isinstance(res, tuple):
        if not res[0]:
            return False
        cp = res[1]
    else:
        cp = res
    if not cp:
        return False
    return cp.distanceTo(point) <= 1e-3


def _project_point_to_plane(point, plane_origin, plane_normal):
    n_vec = adsk.core.Vector3D.create(plane_normal.x, plane_normal.y, plane_normal.z)
    if n_vec.length < TOL:
        return None
    n_vec.normalize()
    v = adsk.core.Vector3D.create(
        point.x - plane_origin.x,
        point.y - plane_origin.y,
        point.z - plane_origin.z,
    )
    dist = n_vec.dotProduct(v)
    return adsk.core.Point3D.create(
        point.x - n_vec.x * dist,
        point.y - n_vec.y * dist,
        point.z - n_vec.z * dist,
    )


def _extract_points(res):
    if not res:
        return []
    if isinstance(res, tuple):
        if len(res) >= 2 and isinstance(res[0], bool):
            if not res[0]:
                return []
            return _extract_points(res[1])
        pts = []
        for item in res:
            pts.extend(_extract_points(item))
        return pts
    if hasattr(res, "count") and hasattr(res, "item"):
        pts = []
        for i in range(res.count):
            pts.append(res.item(i))
        return pts
    return [res]


def _intersect_line_with_face(face, origin, direction, ref_point=None):
    if direction.length < TOL:
        return None
    line = adsk.core.Line3D.create(
        origin,
        adsk.core.Point3D.create(
            origin.x + direction.x,
            origin.y + direction.y,
            origin.z + direction.z,
        )
    )
    hit_pts = []
    try:
        if hasattr(face.evaluator, "intersectWithLine"):
            res = face.evaluator.intersectWithLine(line)
            hit_pts = _extract_points(res)
    except:
        hit_pts = []
    if not hit_pts:
        plane = _get_face_plane(face)
        hit = _line_plane_intersection(origin, direction, plane) if plane else None
        if hit and _is_point_on_face(face, hit):
            hit_pts = [hit]
        else:
            return None

    if not ref_point:
        ref_point = origin
    best_pt = None
    best_d = None
    for hit in hit_pts:
        if not hit:
            continue
        d = hit.distanceTo(ref_point)
        if best_d is None or d < best_d:
            best_d = d
            best_pt = hit
    return best_pt


def _find_occurrence_for_component(root, comp):
    if not root or not comp:
        return None
    try:
        occs = root.allOccurrences
        for i in range(occs.count):
            occ = occs.item(i)
            if occ.component == comp:
                return occ
    except:
        pass
    return None


def _proxy_body(body, root):
    if not body:
        return None
    try:
        if getattr(body, "assemblyContext", None):
            return body
    except:
        pass
    try:
        comp = body.parentComponent
    except:
        comp = None
    occ = _find_occurrence_for_component(root, comp) if comp else None
    if occ:
        try:
            return body.createForAssemblyContext(occ)
        except:
            return None
    return body


def _proxy_face(face, root):
    if not face:
        return None
    try:
        if getattr(face, "assemblyContext", None):
            return face
    except:
        pass
    try:
        comp = face.body.parentComponent
    except:
        comp = None
    occ = _find_occurrence_for_component(root, comp) if comp else None
    if occ:
        try:
            return face.createForAssemblyContext(occ)
        except:
            return None
    return face


def _collect_column_bodies(sel_input, root):
    bodies = {}

    def add_body(body, name_candidates):
        if not body or not body.isSolid:
            return
        body = _proxy_body(body, root)
        if not body:
            return
        try:
            key = body.entityToken
        except:
            key = None
        if not key:
            try:
                key = body.tempId
            except:
                key = id(body)
        if key not in bodies:
            bodies[key] = {
                "body": body,
                "names": [n for n in name_candidates if n],
            }

    for i in range(sel_input.selectionCount):
        ent = sel_input.selection(i).entity

        occ = adsk.fusion.Occurrence.cast(ent)
        if occ:
            names = [occ.name]
            try:
                names.append(occ.component.name)
            except:
                pass
            for j in range(occ.bRepBodies.count):
                add_body(occ.bRepBodies.item(j), names)
            continue

        comp = adsk.fusion.Component.cast(ent)
        if comp:
            names = [comp.name]
            for j in range(comp.bRepBodies.count):
                add_body(comp.bRepBodies.item(j), names)
            continue

        body = adsk.fusion.BRepBody.cast(ent)
        if body:
            names = [body.name]
            try:
                names.append(body.parentComponent.name)
            except:
                pass
            add_body(body, names)

    return list(bodies.values())


def _candidate_side_faces(body, axis_dir):
    faces = []
    for face in body.faces:
        plane = _get_face_plane(face)
        if not plane:
            continue
        n = plane.normal
        if not n or n.length < TOL:
            continue
        n_vec = adsk.core.Vector3D.create(n.x, n.y, n.z)
        n_vec.normalize()
        if abs(n_vec.dotProduct(axis_dir)) > 0.2:
            continue
        try:
            area = face.areaProperties().area
        except:
            area = 0.0
        faces.append({
            "face": face,
            "plane": plane,
            "normal": n_vec,
            "area": area,
        })

    if not faces:
        return []

    # Group by normal direction (inner/outer pairs collapse).
    groups = []
    for info in faces:
        d = _canon_dir(info["normal"])
        placed = False
        for g in groups:
            if g["dir"].crossProduct(d).length < ANGLE_TOL:
                g["faces"].append(info)
                placed = True
                break
        if not placed:
            groups.append({"dir": d, "faces": [info]})

    # Keep the largest-area face per direction (outer face for that side).
    reps = []
    for g in groups:
        best = max(g["faces"], key=lambda f: f["area"])
        reps.append(best)

    return reps


def _inboard_dir(face_normal, plane_origin, body_center):
    to_center = adsk.core.Vector3D.create(
        body_center.x - plane_origin.x,
        body_center.y - plane_origin.y,
        body_center.z - plane_origin.z,
    )
    if face_normal.dotProduct(to_center) > 0:
        return _normalise(face_normal)
    out = adsk.core.Vector3D.create(-face_normal.x, -face_normal.y, -face_normal.z)
    return _normalise(out)


def _choose_pair_hit(upper, lower, side_faces, inboard_u, wall_faces, axis_dir):
    best = None
    axis_n = _normalise(axis_dir)
    for info in side_faces:
        plane = info["plane"]
        n_vec = info["normal"]
        inboard_dir = info.get("inboard_dir")
        if not inboard_dir:
            continue

        upper_on = _project_point_to_plane(upper, plane.origin, n_vec)
        lower_on = _project_point_to_plane(lower, plane.origin, n_vec)
        if not upper_on or not lower_on:
            continue

        upper_start = _offset_point(upper_on, inboard_dir, inboard_u)
        lower_start = _offset_point(lower_on, inboard_dir, inboard_u)
        outward_dir = adsk.core.Vector3D.create(-inboard_dir.x, -inboard_dir.y, -inboard_dir.z)

        for face in wall_faces:
            w_plane = _get_face_plane(face)
            if not w_plane or not w_plane.normal:
                continue
            w_dir = adsk.core.Vector3D.create(w_plane.normal.x, w_plane.normal.y, w_plane.normal.z)
            w_dir.normalize()
            proj = axis_n.copy()
            proj.scaleBy(w_dir.dotProduct(axis_n))
            w_dir = adsk.core.Vector3D.create(
                w_dir.x - proj.x,
                w_dir.y - proj.y,
                w_dir.z - proj.z,
            )
            if w_dir.length < TOL:
                continue
            w_dir.normalize()
            if w_dir.dotProduct(outward_dir) < 0:
                w_dir.scaleBy(-1.0)
            if DEBUG_STUB_ARMS:
                d = w_dir
                _dbg(
                    f"Pair hit check: side_n=({n_vec.x:.4f},{n_vec.y:.4f},{n_vec.z:.4f}) "
                    f"wall_dir=({d.x:.4f},{d.y:.4f},{d.z:.4f})"
                )

            hit = _intersect_line_with_face(face, upper_start, w_dir, upper_start)
            if not hit:
                continue
            dist = upper_start.distanceTo(hit)
            if best is None or dist < best["dist"]:
                best = {
                    "upper_start": upper_start,
                    "lower_start": lower_start,
                    "hit": hit,
                    "dir": w_dir,
                    "side_n": n_vec,
                    "dist": dist,
                }
    return best


def _collect_wall_faces(sel_input, root):
    faces = {}
    for i in range(sel_input.selectionCount):
        ent = sel_input.selection(i).entity
        face = adsk.fusion.BRepFace.cast(ent)
        if face:
            face = _proxy_face(face, root)
            if not face:
                continue
            try:
                key = face.entityToken
            except:
                key = id(face)
            faces[key] = face
            continue
        body = adsk.fusion.BRepBody.cast(ent)
        if body:
            body = _proxy_body(body, root)
            if not body:
                continue
            for j in range(body.faces.count):
                f = body.faces.item(j)
                f = _proxy_face(f, root)
                if not f:
                    continue
                try:
                    key = f.entityToken
                except:
                    key = id(f)
                faces[key] = f
            continue
    return list(faces.values())


def _next_sketch_name(root, base):
    existing = set()
    for i in range(root.sketches.count):
        try:
            existing.add(root.sketches.item(i).name)
        except:
            pass
    if base not in existing:
        return base
    idx = 2
    while f"{base} {idx}" in existing:
        idx += 1
    return f"{base} {idx}"


def _execute(args):
    design = adsk.fusion.Design.cast(ctx.app().activeProduct)
    if not design:
        ctx.ui().messageBox("No active design.")
        return
    root = design.rootComponent
    um = design.unitsManager

    cmd = args.command
    inputs = cmd.commandInputs

    sel_cols = adsk.core.SelectionCommandInput.cast(inputs.itemById("stub_cols"))
    sel_wall = adsk.core.SelectionCommandInput.cast(inputs.itemById("stub_wall"))
    count_in = adsk.core.IntegerSpinnerCommandInput.cast(inputs.itemById("stub_points"))

    if not sel_cols or sel_cols.selectionCount == 0:
        ctx.ui().messageBox("Select at least one RHS column body.")
        return
    if not sel_wall or sel_wall.selectionCount == 0:
        ctx.ui().messageBox("Select one or more wall faces or bodies.")
        return

    def mm_val(cid):
        v = adsk.core.ValueCommandInput.cast(inputs.itemById(cid))
        return um.convert(v.value, um.internalUnits, "mm")

    bottom_mm = mm_val("stub_bottom")
    top_mm = mm_val("stub_top")
    inboard_mm = mm_val("stub_inboard")
    count = count_in.value if count_in else 6

    bottom_u = um.convert(bottom_mm, "mm", um.internalUnits)
    top_u = um.convert(top_mm, "mm", um.internalUnits)
    inboard_u = um.convert(inboard_mm, "mm", um.internalUnits)

    bodies = _collect_column_bodies(sel_cols, root)
    faces = _collect_wall_faces(sel_wall, root)
    if not bodies:
        ctx.ui().messageBox("No valid RHS/SHS bodies selected.")
        return
    if not faces:
        ctx.ui().messageBox("No valid wall faces found.")
        return

    _dbg(f"Selected bodies={len(bodies)}, wall_faces={len(faces)}, points={count}")
    if DEBUG_STUB_ARMS:
        for idx, face in enumerate(faces):
            occ = getattr(face, "assemblyContext", None)
            plane = _get_face_plane(face)
            if plane and plane.normal:
                n = _normalise(plane.normal)
                n_label = f"({n.x:.4f},{n.y:.4f},{n.z:.4f})"
            else:
                n_label = "n/a"
            ctx_label = occ.name if occ else "native"
            _dbg(f"Wall face {idx}: context={ctx_label} plane_n={n_label}")

    logger.log_command(
        CMD_NAME,
        {
            "bodies": len(bodies),
            "wall_faces": len(faces),
            "points": count,
            "bottom_mm": bottom_mm,
            "top_mm": top_mm,
            "inboard_mm": inboard_mm,
        },
    )

    sk = root.sketches.add(root.xYConstructionPlane)
    sk.is3D = True
    try:
        sk.name = _next_sketch_name(root, "StubArms")
    except:
        pass
    lines = sk.sketchCurves.sketchLines

    lines_created = 0
    cols_skipped = []
    pair_missed = 0

    for entry in bodies:
        body = entry["body"]
        name_candidates = entry.get("names", [])
        label = name_candidates[0] if name_candidates else (body.name or "<unnamed>")

        axis = _get_body_axis(body)
        axis_dir, bottom, top, length = _axis_endpoints(body, axis) if axis else (None, None, None, None)
        if not axis_dir or not bottom or not top or not length:
            _dbg(f"Skip body='{label}': axis/length invalid")
            cols_skipped.append(label)
            continue

        name_ok = any(_name_matches_rhs_shs(n) for n in name_candidates)
        geom_ok = _looks_like_rhs_shs(body, axis_dir)
        if not name_ok and not geom_ok:
            _dbg(f"Skip body='{label}': not RHS/SHS (name/geometry check failed)")
            cols_skipped.append(label)
            continue

        center = _get_body_center(body)
        if not center:
            _dbg(f"Skip body='{label}': no center")
            cols_skipped.append(label)
            continue

        side_faces = _candidate_side_faces(body, axis_dir)
        if not side_faces:
            _dbg(f"Skip body='{label}': no side faces")
            cols_skipped.append(label)
            continue
        _dbg(f"Body='{label}': side face candidates={len(side_faces)}")

        for info in side_faces:
            inboard_dir = _inboard_dir(info["normal"], info["plane"].origin, center)
            info["inboard_dir"] = inboard_dir
            if DEBUG_STUB_ARMS:
                n = info["normal"]
                d = inboard_dir
                _dbg(
                    f"Body='{label}' side_n=({n.x:.4f},{n.y:.4f},{n.z:.4f}) "
                    f"inboard_dir=({d.x:.4f},{d.y:.4f},{d.z:.4f})"
                )

        span = length - bottom_u - top_u
        if count < 2 or span <= TOL:
            _dbg(f"Skip body='{label}': span={span:.4f} count={count}")
            cols_skipped.append(label)
            continue
        spacing = span / float(count - 1)
        if spacing <= TOL:
            _dbg(f"Skip body='{label}': spacing={spacing:.4f}")
            cols_skipped.append(label)
            continue

        points = []
        for i in range(count):
            dist = bottom_u + spacing * i
            points.append(_offset_point(bottom, axis_dir, dist))

        _dbg(
            f"Body='{label}' axis=({axis_dir.x:.4f},{axis_dir.y:.4f},{axis_dir.z:.4f}) "
            f"len={length:.4f} bottom=({bottom.x:.4f},{bottom.y:.4f},{bottom.z:.4f}) "
            f"top=({top.x:.4f},{top.y:.4f},{top.z:.4f}) spacing={spacing:.4f}"
        )
        for i in range(len(points) - 1):
            upper = points[i]
            lower = points[i + 1]

            hit_info = _choose_pair_hit(upper, lower, side_faces, inboard_u, faces, axis_dir)
            if not hit_info:
                _dbg(f"Pair {i}: no wall hit from side faces body='{label}'")
                pair_missed += 1
                continue

            lines.addByTwoPoints(hit_info["upper_start"], hit_info["hit"])
            lines.addByTwoPoints(hit_info["lower_start"], hit_info["hit"])
            lines_created += 2

    try:
        ctx.app().activeViewport.refresh()
    except:
        pass

    msg = [f"Created {lines_created} stub arm line(s) in sketch '{sk.name}'."]
    if cols_skipped:
        msg.append("Skipped columns:\n  " + "\n  ".join(sorted(set(cols_skipped))))
    if pair_missed:
        msg.append(f"Missed {pair_missed} pair(s) (no wall hit or body hit).")
    ctx.ui().messageBox("\n\n".join(msg))


def register(ui, panel):
    cmd_def = ui.commandDefinitions.itemById(CMD_ID)
    if not cmd_def:
        cmd_def = ui.commandDefinitions.addButtonDefinition(
            CMD_ID, CMD_NAME, CMD_TOOLTIP, RESOURCE_FOLDER
        )

    created_handler = StubArmsCreatedHandler()
    cmd_def.commandCreated.add(created_handler)
    ctx.add_handler(created_handler)

    if not panel.controls.itemById(CMD_ID):
        ctrl = panel.controls.addCommand(cmd_def)
        ctrl.isPromoted = True
        ctrl.isPromotedByDefault = True
