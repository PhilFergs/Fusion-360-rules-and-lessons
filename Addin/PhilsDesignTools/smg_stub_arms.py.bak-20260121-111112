import adsk.core, adsk.fusion, traceback, os
import smg_context as ctx
import smg_logger as logger


CMD_ID = "PhilsDesignTools_StubArms"
CMD_NAME = "Stub Arms To Wall"
CMD_TOOLTIP = "Create stub arm sketch lines from RHS columns to the wall."
RESOURCE_FOLDER = os.path.join(os.path.dirname(__file__), "resources", CMD_ID)

TOL = 1e-6
ANGLE_TOL = 1e-3
DEBUG_STUB_ARMS = True
DEBUG_WALL_MARKERS = True


class StubArmsExecuteHandler(adsk.core.CommandEventHandler):
    def notify(self, args):
        try:
            _execute(args)
        except:
            logger.log("Stub Arms command failed:\n" + traceback.format_exc())
            ctx.ui().messageBox("Stub Arms command failed:\n" + traceback.format_exc())


class StubArmsCreatedHandler(adsk.core.CommandCreatedEventHandler):
    def notify(self, args):
        try:
            design = adsk.fusion.Design.cast(ctx.app().activeProduct)
            if not design:
                ctx.ui().messageBox("No active design.")
                return
            um = design.unitsManager
            length_units = um.defaultLengthUnits or "mm"

            cmd = args.command
            cmd.isRepeatable = True
            inputs = cmd.commandInputs

            if inputs.itemById("stub_cols"):
                return

            sel_cols = inputs.addSelectionInput(
                "stub_cols",
                "RHS/SHS column faces",
                "Select a planar face on the RHS/SHS column"
            )
            sel_cols.addSelectionFilter("Faces")
            sel_cols.setSelectionLimits(1, 0)

            sel_wall = inputs.addSelectionInput(
                "stub_wall",
                "Wall faces",
                "Select wall faces or surface bodies"
            )
            sel_wall.addSelectionFilter("Faces")
            sel_wall.addSelectionFilter("Bodies")
            sel_wall.setSelectionLimits(1, 0)

            inputs.addIntegerSpinnerCommandInput(
                "stub_points",
                "Connection points",
                2,
                20,
                1,
                6
            )

            def v(mm):
                return adsk.core.ValueInput.createByString(f"{mm} mm")

            inputs.addValueInput("stub_bottom", "Bottom offset", length_units, v(500.0))
            inputs.addValueInput("stub_top", "Top offset", length_units, v(150.0))
            inputs.addValueInput("stub_inboard", "Inboard offset", length_units, v(25.0))

            on_exec = StubArmsExecuteHandler()
            cmd.execute.add(on_exec)
            ctx.add_handler(on_exec)
        except:
            logger.log("Stub Arms CommandCreated failed:\n" + traceback.format_exc())
            ctx.ui().messageBox("Stub Arms CommandCreated failed:\n" + traceback.format_exc())


def _dbg(message):
    if DEBUG_STUB_ARMS:
        logger.log(f"{CMD_NAME} DEBUG: {message}")


def _normalise(v):
    out = adsk.core.Vector3D.create(v.x, v.y, v.z)
    if out.length > TOL:
        out.normalize()
    return out


def _canon_dir(v):
    v2 = _normalise(v)
    if v2.x < 0 or (abs(v2.x) < TOL and v2.y < 0) or \
       (abs(v2.x) < TOL and abs(v2.y) < TOL and v2.z < 0):
        v2.scaleBy(-1)
    return v2


def _get_body_center(body):
    try:
        props = body.physicalProperties
        if props:
            com = props.centerOfMass
            if com:
                return com
    except:
        pass

    bb = body.boundingBox
    mp = bb.minPoint
    xp = bb.maxPoint
    return adsk.core.Point3D.create(
        (mp.x + xp.x) * 0.5,
        (mp.y + xp.y) * 0.5,
        (mp.z + xp.z) * 0.5,
    )


def _get_body_axis(body):
    clusters = []
    for e in body.edges:
        line = adsk.core.Line3D.cast(e.geometry)
        if not line:
            continue
        sp = line.startPoint
        ep = line.endPoint
        vec = adsk.core.Vector3D.create(
            ep.x - sp.x,
            ep.y - sp.y,
            ep.z - sp.z,
        )
        length = vec.length
        if length < TOL:
            continue
        d = _canon_dir(vec)

        placed = False
        for c in clusters:
            if c["dir"].crossProduct(d).length < ANGLE_TOL:
                c["tot"] += length
                placed = True
                break
        if not placed:
            clusters.append({"dir": d, "tot": length})

    if not clusters:
        return None

    clusters.sort(key=lambda c: c["tot"], reverse=True)
    return clusters[0]["dir"]


def _axis_endpoints(body, axis):
    center = _get_body_center(body)
    if not center or not axis:
        return None, None, None, None

    min_t = None
    max_t = None
    for v in body.vertices:
        p = v.geometry
        diff = adsk.core.Vector3D.create(
            p.x - center.x,
            p.y - center.y,
            p.z - center.z,
        )
        t = diff.dotProduct(axis)
        if min_t is None:
            min_t = max_t = t
        else:
            min_t = min(min_t, t)
            max_t = max(max_t, t)

    if min_t is None or abs(max_t - min_t) < TOL:
        return None, None, None, None

    bottom = adsk.core.Point3D.create(
        center.x + axis.x * min_t,
        center.y + axis.y * min_t,
        center.z + axis.z * min_t,
    )
    top = adsk.core.Point3D.create(
        center.x + axis.x * max_t,
        center.y + axis.y * max_t,
        center.z + axis.z * max_t,
    )

    # Ensure bottom/top follow world Z so offsets map to "down/up" consistently.
    if bottom.z > top.z:
        bottom, top = top, bottom

    axis_vec = adsk.core.Vector3D.create(
        top.x - bottom.x,
        top.y - bottom.y,
        top.z - bottom.z,
    )
    if axis_vec.length < TOL:
        return None, None, None, None
    axis_vec.normalize()
    length = bottom.distanceTo(top)
    return axis_vec, bottom, top, length


def _looks_like_rhs_shs(body, axis_dir):
    if not body or not axis_dir:
        return False
    side_faces = []
    for face in body.faces:
        plane = adsk.core.Plane.cast(face.geometry)
        if not plane:
            continue
        n = plane.normal
        if not n or n.length < TOL:
            continue
        n_vec = adsk.core.Vector3D.create(n.x, n.y, n.z)
        n_vec.normalize()
        if abs(n_vec.dotProduct(axis_dir)) > 0.2:
            continue
        side_faces.append(n_vec)

    if len(side_faces) < 4:
        return False

    clusters = []
    for n_vec in side_faces:
        d = _canon_dir(n_vec)
        placed = False
        for c in clusters:
            if c["dir"].crossProduct(d).length < ANGLE_TOL:
                c["count"] += 1
                placed = True
                break
        if not placed:
            clusters.append({"dir": d, "count": 1})

    return len(clusters) >= 2


def _offset_point(p, d, dist):
    return adsk.core.Point3D.create(
        p.x + d.x * dist,
        p.y + d.y * dist,
        p.z + d.z * dist,
    )


def _get_face_plane(face):
    if not face:
        return None
    try:
        res = face.evaluator.getPlane()
        if isinstance(res, tuple):
            if res[0]:
                return res[1]
        elif res:
            return res
    except:
        pass
    return adsk.core.Plane.cast(face.geometry)


def _face_centroid(face):
    if not face:
        return None
    try:
        props = face.areaProperties()
        if props and props.centroid:
            return props.centroid
    except:
        pass
    try:
        bb = face.boundingBox
        if bb:
            mp = bb.minPoint
            xp = bb.maxPoint
            return adsk.core.Point3D.create(
                (mp.x + xp.x) * 0.5,
                (mp.y + xp.y) * 0.5,
                (mp.z + xp.z) * 0.5,
            )
    except:
        pass
    return None


def _add_wall_center_marker(root, face, radius_u):
    if not root or not face or radius_u <= 0:
        return None
    center = _face_centroid(face)
    if not center:
        return None
    try:
        sk = root.sketches.add(face)
    except:
        return None
    try:
        sk.name = _next_sketch_name(root, "WallCenter")
    except:
        pass
    try:
        center_sk = sk.modelToSketchSpace(center)
    except:
        center_sk = center
    try:
        sk.sketchCurves.sketchCircles.addByCenterRadius(center_sk, radius_u)
    except:
        pass
    return sk


def _project_point_to_plane(point, plane_origin, plane_normal):
    n_vec = adsk.core.Vector3D.create(plane_normal.x, plane_normal.y, plane_normal.z)
    if n_vec.length < TOL:
        return None
    n_vec.normalize()
    v = adsk.core.Vector3D.create(
        point.x - plane_origin.x,
        point.y - plane_origin.y,
        point.z - plane_origin.z,
    )
    dist = n_vec.dotProduct(v)
    return adsk.core.Point3D.create(
        point.x - n_vec.x * dist,
        point.y - n_vec.y * dist,
        point.z - n_vec.z * dist,
    )


def _component_axes(body, root):
    occ = None
    try:
        occ = getattr(body, "assemblyContext", None)
    except:
        pass
    if not occ:
        try:
            comp = body.parentComponent
        except:
            comp = None
        occ = _find_occurrence_for_component(root, comp) if comp else None

    x = adsk.core.Vector3D.create(1, 0, 0)
    y = adsk.core.Vector3D.create(0, 1, 0)
    z = adsk.core.Vector3D.create(0, 0, 1)
    if occ:
        try:
            tr = occ.transform
            tr.transformVector(x)
            tr.transformVector(y)
            tr.transformVector(z)
        except:
            pass
    return [_normalise(x), _normalise(y), _normalise(z)]


def _extract_points(res):
    if not res:
        return []
    if isinstance(res, tuple):
        if len(res) >= 2 and isinstance(res[0], bool):
            if not res[0]:
                return []
            return _extract_points(res[1])
        pts = []
        for item in res:
            pts.extend(_extract_points(item))
        return pts
    if hasattr(res, "count") and hasattr(res, "item"):
        pts = []
        for i in range(res.count):
            pts.append(res.item(i))
        return pts
    return [res]


def _line_plane_intersection(origin, direction, plane):
    if not plane or direction.length < TOL:
        return None, None
    n = plane.normal
    if not n or n.length < TOL:
        return None, None
    denom = n.dotProduct(direction)
    if abs(denom) < TOL:
        return None, None
    v = adsk.core.Vector3D.create(
        plane.origin.x - origin.x,
        plane.origin.y - origin.y,
        plane.origin.z - origin.z,
    )
    t = n.dotProduct(v) / denom
    hit = adsk.core.Point3D.create(
        origin.x + direction.x * t,
        origin.y + direction.y * t,
        origin.z + direction.z * t,
    )
    return hit, t


def _is_point_on_face(face, point):
    try:
        ev = face.evaluator
        if hasattr(ev, "isPointOnFace"):
            res = ev.isPointOnFace(point)
            if isinstance(res, tuple):
                return bool(res[0])
            return bool(res)
    except:
        pass
    try:
        if hasattr(face.evaluator, "getClosestPointTo"):
            res = face.evaluator.getClosestPointTo(point)
        else:
            res = face.evaluator.getClosestPoint(point)
    except:
        return False
    if isinstance(res, tuple):
        if not res[0]:
            return False
        cp = res[1]
    else:
        cp = res
    if not cp:
        return False
    return cp.distanceTo(point) <= 1e-3


def _closest_point_on_face(face, point):
    try:
        if hasattr(face.evaluator, "getClosestPointTo"):
            res = face.evaluator.getClosestPointTo(point)
        else:
            res = face.evaluator.getClosestPoint(point)
    except:
        return None
    if isinstance(res, tuple):
        if not res[0]:
            return None
        return res[1]
    return res


def _to_local_point(point, occ):
    if not point or not occ:
        return point
    try:
        inv = occ.transform.copy()
        inv.invert()
        p = adsk.core.Point3D.create(point.x, point.y, point.z)
        p.transformBy(inv)
        return p
    except:
        return point


def _to_local_vector(vec, occ):
    if not vec or not occ:
        return vec
    try:
        inv = occ.transform.copy()
        inv.invert()
        v = adsk.core.Vector3D.create(vec.x, vec.y, vec.z)
        inv.transformVector(v)
        return v
    except:
        return vec


def _to_world_point(point, occ):
    if not point or not occ:
        return point
    try:
        p = adsk.core.Point3D.create(point.x, point.y, point.z)
        p.transformBy(occ.transform)
        return p
    except:
        return point


def _intersect_ray_with_face(face, origin, direction):
    if direction.length < TOL:
        return None
    d = _normalise(direction)
    line = adsk.core.Line3D.create(
        origin,
        adsk.core.Point3D.create(
            origin.x + d.x,
            origin.y + d.y,
            origin.z + d.z,
        ),
    )
    hit_pts = []
    try:
        if hasattr(face.evaluator, "intersectWithLine"):
            res = face.evaluator.intersectWithLine(line)
            hit_pts = _extract_points(res)
    except:
        hit_pts = []
    if not hit_pts:
        plane = _get_face_plane(face)
        if plane:
            hit, t = _line_plane_intersection(origin, d, plane)
            if hit and t > TOL:
                if _is_point_on_face(face, hit):
                    hit_pts = [hit]
                else:
                    cp = _closest_point_on_face(face, hit)
                    if cp:
                        if DEBUG_STUB_ARMS:
                            dist = cp.distanceTo(hit)
                            _dbg(f"Ray hit plane outside face; snapping to closest point (dist={dist:.4f}).")
                        hit_pts = [cp]
    best_pt = None
    best_t = None
    for hit in hit_pts:
        if not hit:
            continue
        v = adsk.core.Vector3D.create(
            hit.x - origin.x,
            hit.y - origin.y,
            hit.z - origin.z,
        )
        t = v.dotProduct(d)
        if t <= TOL:
            continue
        if best_t is None or t < best_t:
            best_t = t
            best_pt = hit
    return best_pt


def _intersect_ray_with_faces(origin, direction, faces):
    best = None
    best_t = None
    for entry in faces:
        face = entry.get("asm") if isinstance(entry, dict) else entry
        if not face:
            continue
        hit = _intersect_ray_with_face(face, origin, direction)
        if not hit:
            continue
        v = adsk.core.Vector3D.create(
            hit.x - origin.x,
            hit.y - origin.y,
            hit.z - origin.z,
        )
        t = v.dotProduct(direction)
        if t <= TOL:
            continue
        if best_t is None or t < best_t:
            best_t = t
            best = hit
    return best


def _line_dir_for_face(face_normal, axis_dir, comp_axes):
    n = _normalise(face_normal)
    axis_n = _normalise(axis_dir)
    for axis in comp_axes:
        if abs(axis.dotProduct(n)) > 0.2:
            continue
        if abs(axis.dotProduct(axis_n)) > 0.2:
            continue
        return _normalise(axis)
    d = axis_n.crossProduct(n)
    if d.length < TOL:
        return None
    d.normalize()
    return d


def _face_span_along_dir(face, direction):
    if not face or direction.length < TOL:
        return None
    d = _normalise(direction)
    min_t = None
    max_t = None
    try:
        verts = face.vertices
    except:
        verts = None
    if not verts or verts.count == 0:
        return None
    for i in range(verts.count):
        p = verts.item(i).geometry
        t = p.x * d.x + p.y * d.y + p.z * d.z
        if min_t is None:
            min_t = max_t = t
        else:
            min_t = min(min_t, t)
            max_t = max(max_t, t)
    if min_t is None:
        return None
    return max_t - min_t




def _find_occurrence_for_component(root, comp):
    if not root or not comp:
        return None
    try:
        occs = root.allOccurrences
        for i in range(occs.count):
            occ = occs.item(i)
            if occ.component == comp:
                return occ
    except:
        pass
    return None


def _proxy_body(body, root):
    if not body:
        return None
    try:
        if getattr(body, "assemblyContext", None):
            return body
    except:
        pass
    try:
        comp = body.parentComponent
    except:
        comp = None
    occ = _find_occurrence_for_component(root, comp) if comp else None
    if occ:
        try:
            return body.createForAssemblyContext(occ)
        except:
            return None
    return body


def _proxy_face(face, root):
    if not face:
        return None
    try:
        if getattr(face, "assemblyContext", None):
            return face
    except:
        pass
    try:
        comp = face.body.parentComponent
    except:
        comp = None
    occ = _find_occurrence_for_component(root, comp) if comp else None
    if occ:
        try:
            return face.createForAssemblyContext(occ)
        except:
            return None
    return face


def _collect_column_faces(sel_input, root):
    faces = {}
    for i in range(sel_input.selectionCount):
        ent = sel_input.selection(i).entity
        face = adsk.fusion.BRepFace.cast(ent)
        if not face:
            continue
        asm = _proxy_face(face, root)
        if not asm:
            continue
        try:
            key = asm.entityToken
        except:
            key = id(asm)
        if key not in faces:
            faces[key] = asm
    return list(faces.values())


def _collect_wall_faces(sel_input, root):
    faces = {}
    for i in range(sel_input.selectionCount):
        ent = sel_input.selection(i).entity
        face = adsk.fusion.BRepFace.cast(ent)
        if face:
            occ = getattr(face, "assemblyContext", None)
            native = getattr(face, "nativeObject", None) or face
            asm = face if occ else _proxy_face(face, root)
            if not asm:
                continue
            try:
                key = asm.entityToken
            except:
                key = id(asm)
            faces[key] = {
                "asm": asm,
                "native": native,
                "occ": occ,
            }
            continue
        body = adsk.fusion.BRepBody.cast(ent)
        if body:
            body = _proxy_body(body, root)
            if not body:
                continue
            for j in range(body.faces.count):
                f = body.faces.item(j)
                occ = getattr(f, "assemblyContext", None)
                native = getattr(f, "nativeObject", None) or f
                asm = f if occ else _proxy_face(f, root)
                if not asm:
                    continue
                try:
                    key = asm.entityToken
                except:
                    key = id(asm)
                faces[key] = {
                    "asm": asm,
                    "native": native,
                    "occ": occ,
                }
    return list(faces.values())


def _next_sketch_name(root, base):
    existing = set()
    for i in range(root.sketches.count):
        try:
            existing.add(root.sketches.item(i).name)
        except:
            pass
    if base not in existing:
        return base
    idx = 2
    while f"{base} {idx}" in existing:
        idx += 1
    return f"{base} {idx}"


def _execute(args):
    design = adsk.fusion.Design.cast(ctx.app().activeProduct)
    if not design:
        ctx.ui().messageBox("No active design.")
        return
    root = design.rootComponent
    um = design.unitsManager

    cmd = args.command
    inputs = cmd.commandInputs

    sel_cols = adsk.core.SelectionCommandInput.cast(inputs.itemById("stub_cols"))
    sel_wall = adsk.core.SelectionCommandInput.cast(inputs.itemById("stub_wall"))
    count_in = adsk.core.IntegerSpinnerCommandInput.cast(inputs.itemById("stub_points"))

    if not sel_cols or sel_cols.selectionCount == 0:
        ctx.ui().messageBox("Select at least one RHS column face.")
        return
    if not sel_wall or sel_wall.selectionCount == 0:
        ctx.ui().messageBox("Select at least one wall face or body.")
        return

    def mm_val(cid):
        v = adsk.core.ValueCommandInput.cast(inputs.itemById(cid))
        return um.convert(v.value, um.internalUnits, "mm")

    bottom_mm = mm_val("stub_bottom")
    top_mm = mm_val("stub_top")
    count = count_in.value if count_in else 6

    bottom_u = um.convert(bottom_mm, "mm", um.internalUnits)
    top_u = um.convert(top_mm, "mm", um.internalUnits)
    default_line_len = um.convert(100.0, "mm", um.internalUnits)

    faces = _collect_column_faces(sel_cols, root)
    if not faces:
        ctx.ui().messageBox("No valid RHS/SHS faces selected.")
        return
    wall_faces = _collect_wall_faces(sel_wall, root)
    if not wall_faces:
        ctx.ui().messageBox("No valid wall faces selected.")
        return

    _dbg(f"Selected faces={len(faces)}, wall_faces={len(wall_faces)}, points={count}")

    logger.log_command(
        CMD_NAME,
        {
            "faces": len(faces),
            "wall_faces": len(wall_faces),
            "points": count,
            "bottom_mm": bottom_mm,
            "top_mm": top_mm,
        },
    )

    if DEBUG_WALL_MARKERS:
        marker_radius_u = um.convert(10.0, "mm", um.internalUnits)
        for entry in wall_faces:
            face = entry["asm"] if isinstance(entry, dict) else entry
            sk = _add_wall_center_marker(root, face, marker_radius_u)
            if sk and DEBUG_STUB_ARMS:
                _dbg(f"Wall marker sketch='{sk.name}'")

    lines_created = 0
    cols_skipped = []
    pair_missed = 0

    for face in faces:
        body = face.body
        label = body.name or "<unnamed>"
        plane = _get_face_plane(face)
        if not plane:
            _dbg(f"Skip body='{label}': selected face not planar")
            cols_skipped.append(label)
            continue

        axis = _get_body_axis(body)
        axis_dir, bottom, top, length = _axis_endpoints(body, axis) if axis else (None, None, None, None)
        if not axis_dir or not bottom or not top or not length:
            _dbg(f"Skip body='{label}': axis/length invalid")
            cols_skipped.append(label)
            continue

        if not _looks_like_rhs_shs(body, axis_dir):
            _dbg(f"Skip body='{label}': not RHS/SHS (name/geometry check failed)")
            cols_skipped.append(label)
            continue

        comp_axes = _component_axes(body, root)

        span = length - bottom_u - top_u
        if count < 2 or span <= TOL:
            _dbg(f"Skip body='{label}': span={span:.4f} count={count}")
            cols_skipped.append(label)
            continue
        spacing = span / float(count - 1)
        if spacing <= TOL:
            _dbg(f"Skip body='{label}': spacing={spacing:.4f}")
            cols_skipped.append(label)
            continue

        points = []
        for i in range(count):
            dist = bottom_u + spacing * i
            points.append(_offset_point(bottom, axis_dir, dist))

        _dbg(
            f"Body='{label}' axis=({axis_dir.x:.4f},{axis_dir.y:.4f},{axis_dir.z:.4f}) "
            f"len={length:.4f} bottom=({bottom.x:.4f},{bottom.y:.4f},{bottom.z:.4f}) "
            f"top=({top.x:.4f},{top.y:.4f},{top.z:.4f}) spacing={spacing:.4f}"
        )
        line_dir = _line_dir_for_face(plane.normal, axis_dir, comp_axes)
        if not line_dir:
            _dbg(f"Skip body='{label}': line dir invalid")
            cols_skipped.append(label)
            continue
        wall_dir = _normalise(line_dir)

        span = _face_span_along_dir(face, line_dir)
        line_len = span * 0.9 if span and span > TOL else default_line_len
        half_len = line_len * 0.5

        try:
            sk = root.sketches.add(face)
        except:
            _dbg(f"Skip body='{label}': failed to create sketch on face")
            cols_skipped.append(label)
            continue
        try:
            sk.name = _next_sketch_name(root, f"StubArms {label}")
        except:
            pass
        lines = sk.sketchCurves.sketchLines

        face_points = []
        for p in points:
            p_on = _project_point_to_plane(p, plane.origin, plane.normal)
            if not p_on:
                continue
            face_points.append(p_on)
            start = _offset_point(p_on, line_dir, -half_len)
            end = _offset_point(p_on, line_dir, half_len)
            try:
                start_sk = sk.modelToSketchSpace(start)
                end_sk = sk.modelToSketchSpace(end)
            except:
                start_sk = start
                end_sk = end
            lines.addByTwoPoints(start_sk, end_sk)
            lines_created += 1

        for i in range(len(face_points) - 1):
            lower = face_points[i]
            upper = face_points[i + 1]
            mid = adsk.core.Point3D.create(
                (upper.x + lower.x) * 0.5,
                (upper.y + lower.y) * 0.5,
                (upper.z + lower.z) * 0.5,
            )

            hit = None
            hit_from = "upper"
            hit = _intersect_ray_with_faces(upper, wall_dir, wall_faces)
            if not hit:
                hit_from = "lower"
                hit = _intersect_ray_with_faces(lower, wall_dir, wall_faces)
            if not hit:
                hit_from = "mid"
                hit = _intersect_ray_with_faces(mid, wall_dir, wall_faces)
            if not hit:
                neg_dir = adsk.core.Vector3D.create(-wall_dir.x, -wall_dir.y, -wall_dir.z)
                hit_from = "upper_neg"
                hit = _intersect_ray_with_faces(upper, neg_dir, wall_faces)
                if not hit:
                    hit_from = "lower_neg"
                    hit = _intersect_ray_with_faces(lower, neg_dir, wall_faces)
                if not hit:
                    hit_from = "mid_neg"
                    hit = _intersect_ray_with_faces(mid, neg_dir, wall_faces)
            if not hit:
                if DEBUG_STUB_ARMS and wall_faces:
                    wf = wall_faces[0]
                    asm_face = wf["asm"]
                    native_face = wf["native"]
                    occ = wf["occ"]
                    plane_w = _get_face_plane(asm_face)
                    n_w = _normalise(plane_w.normal) if plane_w and plane_w.normal else None
                    if occ:
                        mid_l = _to_local_point(mid, occ)
                        dir_l = _to_local_vector(line_dir, occ)
                        plane_l = _get_face_plane(native_face)
                        n_l = _normalise(plane_l.normal) if plane_l and plane_l.normal else None
                        _dbg(
                            f"Missed pair {i}: mid_w=({mid.x:.3f},{mid.y:.3f},{mid.z:.3f}) "
                            f"dir_w=({wall_dir.x:.3f},{wall_dir.y:.3f},{wall_dir.z:.3f}) "
                            f"wall_n_w=({n_w.x:.3f},{n_w.y:.3f},{n_w.z:.3f}) "
                            f"mid_l=({mid_l.x:.3f},{mid_l.y:.3f},{mid_l.z:.3f}) "
                            f"dir_l=({dir_l.x:.3f},{dir_l.y:.3f},{dir_l.z:.3f}) "
                            f"wall_n_l=({n_l.x:.3f},{n_l.y:.3f},{n_l.z:.3f})"
                        )
                    else:
                        _dbg(
                            f"Missed pair {i}: mid=({mid.x:.3f},{mid.y:.3f},{mid.z:.3f}) "
                            f"dir=({wall_dir.x:.3f},{wall_dir.y:.3f},{wall_dir.z:.3f}) "
                            f"wall_n=({n_w.x:.3f},{n_w.y:.3f},{n_w.z:.3f})"
                        )
                pair_missed += 1
                continue
            if DEBUG_STUB_ARMS:
                _dbg(f"Pair {i}: wall hit from {hit_from}")
            try:
                upper_sk = sk.modelToSketchSpace(upper)
                lower_sk = sk.modelToSketchSpace(lower)
                hit_sk = sk.modelToSketchSpace(hit)
            except:
                upper_sk = upper
                lower_sk = lower
                hit_sk = hit
            lines.addByTwoPoints(upper_sk, hit_sk)
            lines.addByTwoPoints(lower_sk, hit_sk)
            lines_created += 2

    try:
        ctx.app().activeViewport.refresh()
    except:
        pass

    msg = [f"Created {lines_created} stub arm line(s)."]
    if cols_skipped:
        msg.append("Skipped columns:\n  " + "\n  ".join(sorted(set(cols_skipped))))
    if pair_missed:
        msg.append(f"Missed {pair_missed} pair(s) (no wall hit).")
    ctx.ui().messageBox("\n\n".join(msg))


def register(ui, panel):
    cmd_def = ui.commandDefinitions.itemById(CMD_ID)
    if not cmd_def:
        cmd_def = ui.commandDefinitions.addButtonDefinition(
            CMD_ID, CMD_NAME, CMD_TOOLTIP, RESOURCE_FOLDER
        )

    created_handler = StubArmsCreatedHandler()
    cmd_def.commandCreated.add(created_handler)
    ctx.add_handler(created_handler)

    if not panel.controls.itemById(CMD_ID):
        ctrl = panel.controls.addCommand(cmd_def)
        ctrl.isPromoted = True
        ctrl.isPromotedByDefault = True
